<h5>Public key formats</h5>
<p>Public key cũng trình bày bằng các cách khác nhau, quan trọng nhất là khoá công khai (public key) được nén hoặc không nén</p>
<p>Như chúng ta thấy ở phiên bản trước, public ky là một điểm trên đường cong elliptic bao gồm một cặp toạ độ (x,y). Nó thường được trình bày với tiền tố 04 theo sau bởi hai số 256 bit, một cái là toạ độ x, một cái là toạ độ y. Tiền tố 04 được sử dụng  để phân biệt các public key không nén, còn các public key nén thì bắt đầu với 02 hoặc 03.</p>
<p>Public key ở đây được tạo bởi private key, hiển thị toạ độ (x,y).</p>
<p>Public key K được định nghĩa như một điểm K = (x,y)</p>
<a>x = F028892BAD...DC341A</a>
<a>y = 07CF33DA18...505BDB</a>
<p>Public key được hiện thị với 520-bit number (130 hex digits) với tiền tố 04, theo sau bởi toạ độ x y: Public key không nén K được hiển thị dưới dạng hex (130 hex digits) như 04xy: </p>
<a>K = 04F028892BAD...505BDB</a>
<h5>Public Key nén</h5>
<p>Các khóa công khai nén được đưa vào bitcoin để giảm kích thước giao dịch và tiết kiệm dung lượng đĩa trên các nút lưu trữ cơ sở dữ liệu khối bitcoin. Hầu hết các giao dịch bao gồm khóa công khai, bắt buộc để xác thực thông tin đăng nhập của chủ sở hữu và chi tiêu bitcoin. Mỗi khóa công khai yêu cầu 520 bit (tiền tố \ + x \ + y), khi nhân với hàng trăm giao dịch trên mỗi khối hoặc hàng chục nghìn lần chuyển đổi mỗi ngày, do đó thêm một lượng đáng kể dữ liệu vào blockchain</p>
<p>Như chúng ta đã thấy trong phần “Khóa công khai” ở trang 65 ở trên, khóa công khai là một điểm (x, y) trên đường cong elliptic. Vì đường cong biểu diễn một hàm toán học, một điểm trên đường cong biểu diễn một giải pháp cho phương trình và do đó nếu chúng ta biết tọa độ x chúng ta có thể tính toán tọa độ y bằng cách giải phương trình y^2 mod p = (x ^3 + 7) mod p. Điều đó cho phép chúng tôi chỉ lưu trữ tọa độ x của điểm khóa công khai, bỏ qua toạ độ y và giảm kích thước của khóa và khoảng trống cần thiết để lưu trữ nó bằng 256 bit. Giảm gần 50% kích thước trong mỗi giao dịch bổ sung thêm nhiều dữ liệu được lưu theo thời gian</p>
<p>Trong khi các khóa công khai không nén có tiền tố là 04, các khóa công cộng nén bắt đầu bằng tiền tố 02 hoặc 03. Hãy xem tại sao có hai tiền tố có thể: vì phía bên trái của phương trình là y^2, có nghĩa là giải pháp cho y là căn bậc hai, có thể có giá trị dương hoặc âm. Bằng trực quan, điều này có nghĩa là tọa độ y kết quả có thể nằm trên trục x hoặc dưới trục x. Như bạn có thể thấy từ đồ thị của đường cong elip, đường cong là đối xứng, có nghĩa là nó được phản xạ giống như một gương bằng trục x. Vì vậy, trong khi chúng ta có thể bỏ qua tọa độ y, chúng ta phải lưu dấu y (dương hoặc âm), hoặc nói cách khác chúng ta phải nhớ nếu nó ở trên hoặc dưới trục x, vì mỗi tùy chọn này đại diện cho điểm khác nhau và một khóa công khai khác. Khi tính đường cong elliptic trong số học nhị phân trên trường hữu hạn của bậc tự p, toạ độ y là chẵn hoặc lẻ, tương ứng với dấu dương / âm như đã giải thích ở trên. Do đó, để phân biệt giữa hai giá trị có thể có của y, chúng tôi lưu trữ một khóa công khai nén với tiền tố 02 nếu y là chẵn, và 03 nếu nó là số lẻ, cho phép phần mềm để suy luận chính xác tọa độ y từ tọa độ x và giải nén khóa công khai đến toàn bộ tọa độ của điểm.</p>
<img src="http://sv1.upsieutoc.com/2018/06/17/Screenshot-from-2018-06-17-10-35-27.png" />
<p>Đây là khóa công khai được tạo trước đó, được hiển thị dưới dạng khóa công cộng nén được lưu trữ trong 264 bit (66 chữ số thập phân) với tiền tố 03 cho biết toạ độ y là số lẻ:</p>
<p>Public key nén K được hiển thị dưới dạng hex (66 hex digits) như K = {02 hoặc 03} x.</p>
<a>K = 03F028892BAD...DC341A</a>
<p>Public key nén ở trên tương ứng với cùng private key, nghĩa là nó được tạo từ cùng private key. Tuy nhiên nó nhìn khác với public key không nén. Quan trọng hơn, nếu chúng ta chuyển đổi Public key nén sang địa chỉ bitcoin sử dụng double-hash function (RIPEMD160(SHA256(K))) nó sẽ tạo ra một địa chỉ bitcoin khác. Đây có thể là mập mờ, gây nhầm lẫn bởi vì nó có nghĩa rằng một single private key có thể tạo một public key được thể hiện ở 2 định dạng khác nhau (nén và không nén), cái này tạo ra 2 địa chỉ bitcoin khác nhau. Tuy nhiên, private key là giống hệt nhau cho 2 địa chỉ bitcoin. </p>
<p>Các public key nén đang dần trở thành mặc định trên các máy khách bitcoin ( bitcoin client), cái mà có tác động đáng kể đến việc giảm kích thước giao dịch.Tuy nhiên, không phải tất cả các máy khách đều hỗ trợ khóa public key nén. Máy client mới hơn cung cấp public key nén phải tính đến các giao dịch từ các máy khách cũ không hỗ trợ khóa public key nén. Điều này là quan trọng khi một ứng dụng ví đang nhập khóa riêng tư (private key) từ một ứng dụng ví bitcoin khác, bởi vì ví mới cần scan the blockchain để tìm transaction tươn ứng với các khoá được nhập này. Địa chỉ bitcoin nào sẽ quét ví bitcoin? Các địa chỉ bitcoin được tạo ra bởi các khóa công khai không nén, hoặc các địa chỉ bitcoin được tạo ra bởi các khóa công khai nén? Cả hai đều là địa chỉ bitcoin hợp lệ và có thể được ký bằng khóa riêng (private key), nhưng chúng là các địa chỉ khác nhau! </p>
<p>Để giải quyết vấn đề này, khi private key được xuất từ một ví, Định dạng nhập Wallet được sử dụng để đại diện cho chúng được triển khai khác nhau trong các ví bitcoin mới hơnđể chỉ ra rằng các khóa riêng này đã được sử dụng để sản xuất các khóa công khai nén và do đó các địa chỉ bitcoin được nén. Điều này cho phép ví nhập dữ liệu vào phân biệt giữa các khóa riêng có nguồn gốc từ các ví cũ hơn hoặc mới hơn và tìm kiếm blockchain cho các giao dịch với các địa chỉ bitcoin tương ứng với các khóa công khai không nén hoặc tương ứng. Hãy xem cách hoạt động này chi tiết hơn, trong phần tiếp theo.</p>
<h5>Compressed Private keys</h5>
<p>Trớ trêu thay, tên "khóa riêng nén" là gây hiểu nhầm, bởi vì khi một khóa riêng được xuất dưới dạng WIF-nén, nó thực sự dài hơn một byte so với khóa riêng "không nén". Đó là bởi vì nó có thêm hậu tố 01 có nghĩa là nó xuất phát từ một ví mới hơn và chỉ nên được sử dụng để tạo ra các khóa public key nén. Khóa riêng không được nén và không thể nén. Thuật ngữ "khóa riêng nén" thực sự có nghĩa là "khóa riêng mà từ đó các khóa công cộng nén phải được bắt nguồn", trong khi "khóa riêng không nén" thực sự có nghĩa là "khóa riêng mà từ đó các khóa công khai không nén nên được bắt nguồn". Bạn chỉ nên tham khảo định dạng xuất dưới dạng “WIF-compressed” hoặc “WIF” và không tham chiếu đến khóa riêng tư dưới dạng “nén” để tránh nhầm lẫn hơn nữa.</p>
<p>Hãy nhớ rằng, các định dạng này không được sử dụng thay thế cho nhau. Trong một ví mới hơn mà thực hiện các khóa công khai nén, các khóa riêng sẽ chỉ được xuất như WIFcompressed (với tiền tố K hoặc L). Nếu ví là một triển khai cũ hơn và không sử dụng khóa công khai nén, các khóa riêng sẽ chỉ được xuất dưới dạng WIF (tiền tố 5). Mục tiêu ở đây là để báo hiệu cho ví nhập các khóa riêng tư này cho dù nó phải tìm kiếm blockchain cho các khóa và địa chỉ công cộng nén hoặc không nén. Nếu một ví bitcoin có thể thực hiện các khóa công khai nén, thì nó sẽ sử dụng các khóa đó trong tất cả các giao dịch. Các khóa riêng trong ví sẽ được sử dụng để lấy các điểm khóa công khai trên đường cong, sẽ được nén. Các khóa công khai nén sẽ được sử dụng để tạo ra các địa chỉ bitcoin và các địa chỉ đó sẽ được sử dụng trong các giao dịch. Khi xuất các khóa riêng tư từ một ví mới thực hiện các khóa công cộng nén, Định dạng nhập Wallet được sửa đổi, với việc bổ sung hậu tố một byte + 01 + vào khóa riêng. Khóa private được mã hóa base58check được gọi là "WIF nén" và bắt đầu bằng chữ cái K hoặc L, thay vì bắt đầu bằng chữ "5" như trường hợp với các khóa được mã hóa WIF (không được nén) từ các ví cũ hơn. Here’s the same key, encoded in WIF and WIF-compressed formats</p>
<img src="http://sv1.upsieutoc.com/2018/06/17/Screenshot-from-2018-06-17-16-22-26.png"/>
<h4>Implementing Keys and Addresses in Python</h4>
<p>Thư viện bitcoin toàn diện nhất trong Python là “pybitcointools” của Vitalik Buterin (https://github.com/vbuterin/pybitcointools) Trong ví dụ mã sau, chúng ta sử dụng thư viện pybitcointools (được nhập dưới dạng “bitcoin”) để tạo và hiển thị các khóa và địa chỉ ở các định dạng khác nhau:</p>
<img src="http://sv1.upsieutoc.com/2018/06/17/Screenshot-from-2018-06-17-16-36-18.png" />
<img src="http://sv1.upsieutoc.com/2018/06/17/Screenshot-from-2018-06-17-16-36-27.png" />
<img src="http://sv1.upsieutoc.com/2018/06/17/Screenshot-from-2018-06-17-16-38-35.png" />
<img src="http://sv1.upsieutoc.com/2018/06/17/Screenshot-from-2018-06-17-16-38-56.png" />
<img src="http://sv1.upsieutoc.com/2018/06/17/Screenshot-from-2018-06-17-16-40-20.png" />
<h4>Wallets</h4>
<p>Wallets là  các container cho khóa riêng, thường được triển khai dưới dạng tệp có cấu trúc hoặc cơ sở dữ liệu đơn giản. Một phương pháp khác để tạo khóa là tạo ra khóa xác định (deterministic key generation).Ở đây bạn lấy được mỗi khóa riêng mới, sử dụng hàm băm một chiều từ khóa riêng trước đó, liên kết chúng theo một chuỗi. Miễn là bạn có thể tạo lại chuỗi đó, bạn chỉ cần khóa đầu tiên (được gọi là khóa gốc (seed key)  hoặc khóa chính (master key) để tạo tất cả chúng. Trong phần này, chúng tôi sẽ xem xét các phương pháp khác nhau của tạo khóa và các cấu trúc ví được xây dựng xung quanh chúng.</p>
<i>Ví có chứa chìa khóa, không phải coin. Các đồng tiền được lưu trữ trên blockchain trong các hình thức đầu ra giao dịch (thường được ghi nhận là vout hoặc txout). Mỗi người dùng có một ví chứa các khóa. Ví là các chuỗi khóa thực sự chứa các cặp khóa riêng / khóa công khai (Xem (đến)). Người dùng ký giao dịch với các khóa, qua đó chứng minh họ sở hữu các kết quả giao dịch (tiền của họ).</i>
